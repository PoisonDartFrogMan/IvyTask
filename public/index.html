<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IvyTask</title>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
</head>
<body>

  <div id="auth-container">
    <h1>IvyTask</h1>
    <p>アカウントを作成、またはログインしてください</p>
    <input type="email" id="email-input" placeholder="メールアドレス">
    <input type="password" id="password-input" placeholder="パスワード">
    <button id="signup-button">サインアップ</button>
    <button id="login-button">ログイン</button>
  </div>

  <main id="app-container" style="display: none;">
    <div id="user-info">
      <span id="user-email"></span>
      <a href="/faq.html" target="_blank" id="faq-button" title="FAQ"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"/></svg></a>
      <button id="logout-button">ログアウト</button>
    </div>
    
    <h1>IvyTask</h1>
    
    <div class="main-controls">
        <button id="manage-labels-button">ラベルを編集</button>
        <button id="reset-day-button">Reset</button>
        <button id="archive-view-button">アーカイブ</button>
    </div>

    <section>
      <h2>Focalist</h2>
      <ul id="today-tasks"></ul>
    </section>

    <section>
      <h2>タスクストック</h2>
      <ul id="stock-tasks"></ul>
    </section>

    <section>
      <h2>新しいタスクを追加</h2>
      <div class="add-task-form">
        <input type="text" id="new-task-input" placeholder="やるべきことを入力...">
        <input type="date" id="due-date-input">
        <button id="add-task-button">ストックに追加</button>
      </div>
      <div id="color-picker">
        </div>
    </section>
  </main>
  
  <div id="archive-container" style="display: none;">
      <h1>アーカイブ</h1>
      <ul id="archive-tasks"></ul>
      <button id="back-to-main-button">メイン画面へ戻る</button>
  </div>
  
  <div id="label-modal-backdrop" class="hidden">
    <div id="label-modal">
        <h2>カテゴリーラベルを管理</h2>
        <ul id="labels-list"></ul>
        <form id="add-label-form">
            <input type="text" id="label-name-input" placeholder="ラベル名 (12文字以内)" maxlength="12" required>
            <div class="label-color-selector">
                <input type="color" id="label-color-input" value="#CCCCCC">
                <button type="submit">新しいラベルを追加</button>
            </div>
        </form>
        <button id="close-label-modal-button">閉じる</button>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, addDoc, query, where, getDocs, getDoc, doc, deleteDoc, updateDoc, orderBy, writeBatch, Timestamp, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBeI8s103OiXXOpRpYc5WBwkJK1lFSzLwM",
      authDomain: "ivy-league-app-95a5d.firebaseapp.com",
      projectId: "ivy-league-app-95a5d",
      storageBucket: "ivy-league-app-95a5d.firebasestorage.app",
      messagingSenderId: "470602099850",
      appId: "1:470602099850:web:1ac19841730eb053341173",
      measurementId: "G-BE4QS8RP2G"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const mainContainer = document.getElementById('app-container');
    const authContainer = document.getElementById('auth-container');
    const archiveContainer = document.getElementById('archive-container');
    const emailInput = document.getElementById('email-input');
    const passwordInput = document.getElementById('password-input');
    const signupButton = document.getElementById('signup-button');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const userEmailSpan = document.getElementById('user-email');
    const addButton = document.getElementById('add-task-button');
    const taskInput = document.getElementById('new-task-input');
    const dueDateInput = document.getElementById('due-date-input');
    const colorPicker = document.getElementById('color-picker');
    const stockList = document.getElementById('stock-tasks');
    const todayList = document.getElementById('today-tasks');
    const archiveList = document.getElementById('archive-tasks');
    const resetDayButton = document.getElementById('reset-day-button');
    const archiveViewButton = document.getElementById('archive-view-button');
    const backToMainButton = document.getElementById('back-to-main-button');
    const manageLabelsButton = document.getElementById('manage-labels-button');
    const labelModalBackdrop = document.getElementById('label-modal-backdrop');
    const closeLabelModalButton = document.getElementById('close-label-modal-button');
    const addLabelForm = document.getElementById('add-label-form');
    const labelNameInput = document.getElementById('label-name-input');
    const labelColorInput = document.getElementById('label-color-input');
    const labelsList = document.getElementById('labels-list');

    let currentUserId = null;
    let selectedLabelId = null;
    let labels = [];
    let unsubscribeLabels = () => {};

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUserId = user.uid;
        authContainer.style.display = 'none';
        mainContainer.style.display = 'block';
        userEmailSpan.textContent = user.email;
        if (unsubscribeLabels) unsubscribeLabels();
        unsubscribeLabels = loadLabels(currentUserId);
        await runDailyAutomation(currentUserId);
        loadTasks(currentUserId);
        activateDragAndDrop();
      } else {
        currentUserId = null;
        authContainer.style.display = 'block';
        mainContainer.style.display = 'none';
        archiveContainer.style.display = 'none';
        if (unsubscribeLabels) unsubscribeLabels();
      }
    });
    
    function loadLabels(userId) {
      const labelsQuery = query(collection(db, "labels"), where("userId", "==", userId));
      return onSnapshot(labelsQuery, (snapshot) => {
        labelsList.innerHTML = '';
        labels = [];
        snapshot.forEach(doc => {
          const label = { id: doc.id, ...doc.data() };
          labels.push(label);
          renderLabelInModal(label);
        });
        updateColorPicker();
      });
    }

    function renderLabelInModal(label) {
        const li = document.createElement('li');
        li.className = 'label-item';
        li.dataset.id = label.id;
        const colorCircle = document.createElement('div');
        colorCircle.className = 'label-color-circle';
        colorCircle.style.backgroundColor = label.color;
        const labelName = document.createElement('span');
        labelName.className = 'label-name';
        labelName.textContent = label.name;
        const deleteBtn = createButton('削除','delete-label-btn');
        li.appendChild(colorCircle);
        li.appendChild(labelName);
        li.appendChild(deleteBtn);
        labelsList.appendChild(li);
    }
    
    function updateColorPicker() {
        colorPicker.innerHTML = '';
        if (labels.length === 0) {
            colorPicker.innerHTML = '<p class="no-labels-message">ラベルがありません。「ラベルを編集」から作成してください。</p>';
            selectedLabelId = null;
            return;
        }
        labels.forEach(label => {
            const choice = document.createElement('div');
            choice.className = 'color-choice';
            choice.dataset.labelId = label.id;
            choice.style.backgroundColor = label.color;
            choice.title = label.name;
            colorPicker.appendChild(choice);
        });
        if (!labels.some(l => l.id === selectedLabelId)) {
            selectedLabelId = labels.length > 0 ? labels[0].id : null;
        }
        if (selectedLabelId) {
            const selectedChoice = colorPicker.querySelector(`[data-label-id="${selectedLabelId}"]`);
            if (selectedChoice) selectedChoice.classList.add('selected');
        }
    }

    async function loadTasks(userId) {
      stockList.innerHTML = '';
      todayList.innerHTML = '';
      const q = query(collection(db, "tasks"), where("userId", "==", userId), where("status", "in", ["stock", "today", "completed"]));
      const querySnapshot = await getDocs(q);
      let tasks = [];
      querySnapshot.forEach(doc => tasks.push({ id: doc.id, ...doc.data() }));
      tasks.sort((a, b) => {
        if (a.status === 'stock' && b.status === 'stock') {
            const aHasDate = a.dueDate;
            const bHasDate = b.dueDate;
            if (aHasDate && !bHasDate) return -1;
            if (!aHasDate && bHasDate) return 1;
            if (aHasDate && bHasDate) return a.dueDate.toMillis() - b.dueDate.toMillis();
        }
        const statusOrder = { 'today': 1, 'completed': 2, 'stock': 3 };
        if (statusOrder[a.status] !== statusOrder[b.status]) return statusOrder[a.status] - statusOrder[b.status];
        return (a.priority || 0) - (b.priority || 0);
      });
      tasks.forEach(task => renderTask(task.id, task));
    }

    async function loadArchivedTasks(userId) {
        archiveList.innerHTML = '';
        const q = query(collection(db, "tasks"), where("userId", "==", userId), where("status", "==", "archived"), orderBy("createdAt", "desc"));
        const querySnapshot = await getDocs(q);
        querySnapshot.forEach((doc) => { renderTask(doc.id, doc.data(), true); });
    }

    function renderTask(id, data, isArchived = false) {
      const newTask = document.createElement('li');
      newTask.dataset.id = id;
      if (data.status === 'completed') newTask.classList.add('completed');
      
      const label = labels.find(l => l.id === data.labelId);
      if (label) {
        newTask.style.borderLeftColor = label.color;
        newTask.style.backgroundColor = `${label.color}20`;
      } else {
        newTask.style.borderLeftColor = '#e0e0e0';
      }

      const taskContent = document.createElement('div');
      taskContent.className = 'task-content';
      const taskLabel = document.createElement('span');
      taskLabel.textContent = data.text;
      taskContent.appendChild(taskLabel);

      if (data.dueDate) {
        const dueDateSpan = document.createElement('small');
        dueDateSpan.className = 'due-date';
        dueDateSpan.textContent = `期日: ${data.dueDate.toDate().toLocaleDateString('ja-JP')}`;
        taskContent.appendChild(dueDateSpan);
      }
      newTask.appendChild(taskContent);

      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'task-buttons';
      
      if (isArchived) {
          buttonsContainer.appendChild(createButton('ストックへ戻す', 'unarchive-btn'));
      } else {
          if (data.status === 'stock') buttonsContainer.appendChild(createButton('Focus', 'move-btn'));
          if (data.status === 'today') {
            buttonsContainer.appendChild(createButton('完了', 'complete-btn'));
            buttonsContainer.appendChild(createButton('ストックへ', 'move-to-stock-btn'));
          }
      }
      buttonsContainer.appendChild(createIconButton('trash-icon.png', 'delete-btn'));
      
      newTask.appendChild(buttonsContainer);

      if (isArchived) {
          archiveList.appendChild(newTask);
      } else if (data.status === 'today' || data.status === 'completed') {
        todayList.appendChild(newTask);
      } else {
        stockList.appendChild(newTask);
      }
    }

    function createButton(text, className) { const button = document.createElement('button'); button.textContent = text; button.className = className; return button; }
    function createIconButton(src, className) { const button = document.createElement('button'); button.className = className; const icon = document.createElement('img'); icon.src = src; icon.alt = className; button.appendChild(icon); return button; }
    function activateDragAndDrop() {
       new Sortable(todayList, {
         animation: 150,
         onEnd: async (evt) => {
          const items = evt.to.children; 
          const batch = writeBatch(db); 
          Array.from(items).forEach((item, index) => { 
            if (item.dataset.id) { 
              const taskDocRef = doc(db, "tasks", item.dataset.id); 
              batch.update(taskDocRef, { priority: index }); 
            } 
          }); 
          await batch.commit(); 
        } 
      }); 
    }
    
    async function runDailyAutomation(userId) {
        const allTasksQuery = query(collection(db, "tasks"), where("userId", "==", userId), where("status", "in", ["stock", "today"]));
        const querySnapshot = await getDocs(allTasksQuery);
        let allTasks = [];
        querySnapshot.forEach(doc => allTasks.push({ ref: doc.ref, ...doc.data() }));
        let todayTasksCount = allTasks.filter(t => t.status === 'today').length;
        const stockTasks = allTasks.filter(t => t.status === 'stock');
        const today = new Date();
        const tomorrow = new Date();
        tomorrow.setDate(today.getDate() + 1);
        today.setHours(0, 0, 0, 0);
        tomorrow.setHours(0, 0, 0, 0);
        const tasksToMove = [];
        const blockedTasks = [];
        stockTasks.forEach(task => {
            if (task.dueDate) {
                const taskDueDate = task.dueDate.toDate();
                taskDueDate.setHours(0, 0, 0, 0);
                if (taskDueDate.getTime() === tomorrow.getTime()) {
                    if (todayTasksCount < 6) {
                        tasksToMove.push(task.ref);
                        todayTasksCount++;
                    } else {
                        blockedTasks.push(task.text);
                    }
                }
            }
        });
        if (tasksToMove.length > 0) {
            const batch = writeBatch(db);
            tasksToMove.forEach((taskRef, index) => {
                batch.update(taskRef, { status: 'today', priority: todayTasksCount + index });
            });
            await batch.commit();
        }
        if (blockedTasks.length > 0) {
            alert(`以下のタスクは、期日が明日ですが、「Focalist」が満杯のため移動できませんでした：\n\n- ${blockedTasks.join('\n- ')}`);
        }
    }

    addButton.addEventListener('click', async () => {
      const taskText = taskInput.value.trim();
      const dueDateValue = dueDateInput.value;
      if (taskText === '' || !currentUserId) return;
      if (!selectedLabelId && labels.length > 0) {
          selectedLabelId = labels[0].id;
      }
      const newTaskData = { userId: currentUserId, text: taskText, status: 'stock', priority: Date.now(), createdAt: serverTimestamp(), labelId: selectedLabelId };
      if (dueDateValue) { newTaskData.dueDate = Timestamp.fromDate(new Date(dueDateValue)); }
      await addDoc(collection(db, "tasks"), newTaskData);
      loadTasks(currentUserId);
      taskInput.value = ''; dueDateInput.value = '';
    });
    
    document.body.addEventListener('click', async (event) => {
        if (event.target.closest('.color-choice')) {
            selectedLabelId = event.target.closest('.color-choice').dataset.labelId;
            updateColorPicker();
            return;
        }
        if (event.target.closest('.due-date')) {
            const taskItem = event.target.closest('li'); if (!taskItem) return; const taskId = taskItem.dataset.id; const taskDocRef = doc(db, "tasks", taskId); const originalDateSpan = event.target; const dateInput = document.createElement('input'); dateInput.type = 'date'; try { const docSnap = await getDoc(taskDocRef); if (docSnap.exists() && docSnap.data().dueDate) { const currentDueDate = docSnap.data().dueDate.toDate(); const year = currentDueDate.getFullYear(); const month = String(currentDueDate.getMonth() + 1).padStart(2, '0'); const day = String(currentDueDate.getDate()).padStart(2, '0'); dateInput.value = `${year}-${month}-${day}`; } } catch (e) { console.error("日付の読み込みエラー:", e); } originalDateSpan.replaceWith(dateInput); dateInput.focus(); const saveAndRevert = async () => { if (dateInput.value) { const newDueDate = Timestamp.fromDate(new Date(dateInput.value)); await updateDoc(taskDocRef, { dueDate: newDueDate }); } loadTasks(currentUserId); }; dateInput.addEventListener('blur', saveAndRevert); dateInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { dateInput.blur(); } });
            return; 
        }
        const taskItem = event.target.closest('li');
        if (taskItem && taskItem.dataset.id) {
            const taskId = taskItem.dataset.id;
            const taskDocRef = doc(db, "tasks", taskId);
            if (event.target.closest('.delete-btn')) { if(confirm('このタスクを完全に削除しますか？')){ await deleteDoc(taskDocRef); } }
            else if (event.target.closest('.move-btn')) { if (todayList.children.length < 6) { await updateDoc(taskDocRef, { status: 'today', priority: todayList.children.length }); } else { alert('「Focalist」は6つまでだッ！'); } }
            else if (event.target.closest('.complete-btn')) { await updateDoc(taskDocRef, { status: 'completed' }); }
            else if (event.target.closest('.move-to-stock-btn')) { await updateDoc(taskDocRef, { status: 'stock', priority: Date.now() }); }
            else if (event.target.closest('.unarchive-btn')) { await updateDoc(taskDocRef, { status: 'stock', priority: Date.now() }); }
        }
    });

    manageLabelsButton.addEventListener('click', () => labelModalBackdrop.classList.remove('hidden'));
    closeLabelModalButton.addEventListener('click', () => labelModalBackdrop.classList.add('hidden'));
    addLabelForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const name = labelNameInput.value.trim();
        const color = labelColorInput.value;
        if (!name || !currentUserId) return;
        if (labels.some(l => l.name === name)) return alert('同じ名前のラベルは既に存在します。');
        await addDoc(collection(db, "labels"), { userId: currentUserId, name: name, color: color, createdAt: serverTimestamp() });
        labelNameInput.value = '';
    });
    labelsList.addEventListener('click', async (event) => {
        if (event.target.closest('.delete-label-btn')) {
            const labelItem = event.target.closest('.label-item');
            const labelId = labelItem.dataset.id;
            if (confirm('このラベルを削除しますか？関連するタスクのラベルは解除されます。')) {
                await deleteDoc(doc(db, "labels", labelId));
            }
        }
    });

    resetDayButton.addEventListener('click', async () => {
        if (!currentUserId || !confirm("Resetしますか？\n完了したタスクはアーカイブされ、未完了のFocalistはストックに戻ります。")) return;
        const q = query(collection(db, "tasks"), where("userId", "==", currentUserId), where("status", "in", ["today", "completed"]));
        const querySnapshot = await getDocs(q);
        const batch = writeBatch(db);
        querySnapshot.forEach(docSnap => {
            const task = docSnap.data();
            if(task.status === 'completed') batch.update(docSnap.ref, { status: 'archived' });
            else if(task.status === 'today') batch.update(docSnap.ref, { status: 'stock', priority: Date.now() });
        });
        await batch.commit();
        loadTasks(currentUserId);
    });

    archiveViewButton.addEventListener('click', () => { mainContainer.style.display = 'none'; archiveContainer.style.display = 'block'; loadArchivedTasks(currentUserId); });
    backToMainButton.addEventListener('click', () => { archiveContainer.style.display = 'none'; mainContainer.style.display = 'block'; loadTasks(currentUserId); });
    
    signupButton.addEventListener('click', () => { const email = emailInput.value; const password = passwordInput.value; if (!email || !password) return alert("メールアドレスとパスワードを入力してください。"); createUserWithEmailAndPassword(auth, email, password).catch((error) => alert('サインアップ失敗: ' + error.message)); });
    loginButton.addEventListener('click', () => { const email = emailInput.value; const password = passwordInput.value; if (!email || !password) return alert("メールアドレスとパスワードを入力してください。"); signInWithEmailAndPassword(auth, email, password).catch((error) => alert('ログイン失敗: ' + error.message)); });
    logoutButton.addEventListener('click', () => { signOut(auth); });
  </script>
</body>
</html>